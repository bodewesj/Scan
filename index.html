// Vervang je bestaande React-component door deze code (of plak in je <script>).
const { useEffect, useRef, useState } = React;

function BarcodeInventory() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const overlayRef = useRef(null);
  const [supported, setSupported] = useState(null);
  const [scanning, setScanning] = useState(false);
  const [lastBarcode, setLastBarcode] = useState("");
  const [articleId, setArticleId] = useState("");
  const [quantity, setQuantity] = useState(1);
  const [items, setItems] = useState([]);
  const [message, setMessage] = useState("");
  const detectorRef = useRef(null);
  const rafRef = useRef(null);
  const streamRef = useRef(null);

  useEffect(() => {
    // Check support & create detector
    if (window.BarcodeDetector) {
      setSupported(true);
      const formats = ["ean_13", "ean_8", "code_128", "code_39", "qr_code", "upc_e", "upc_a", "itf"];
      try {
        detectorRef.current = new window.BarcodeDetector({ formats });
        console.log("BarcodeDetector aangemaakt met formats:", formats);
      } catch (e) {
        detectorRef.current = new window.BarcodeDetector();
        console.log("BarcodeDetector aangemaakt zonder expliciete formats", e);
      }
    } else {
      setSupported(false);
      console.warn("BarcodeDetector niet beschikbaar in deze browser.");
    }
    return () => stopCamera();
  }, []);

  function startCamera() {
    if (scanning) return;
    setMessage("");
    console.log("Start camera: aanvraag media...");
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false })
      .then((stream) => {
        streamRef.current = stream;
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          videoRef.current.setAttribute("playsinline", "true");
          videoRef.current.play();
          console.log("Camera gestart, video element set.");
        }
        setScanning(true);
        // start detectielus met korte timeout zodat video frames beschikbaar zijn
        setTimeout(() => {
          if (detectorRef.current) tickDetect();
        }, 150);
      })
      .catch((err) => {
        console.error("Kon camera niet starten:", err);
        setMessage("Kon camera niet starten: " + err.message);
      });
  }

  function stopCamera() {
    setScanning(false);
    if (rafRef.current) {
      cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
    }
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((t) => t.stop());
      streamRef.current = null;
    }
    console.log("Camera gestopt.");
  }

  async function tickDetect() {
    try {
      if (!videoRef.current || !detectorRef.current || !scanning) return;

      const video = videoRef.current;
      if (video.readyState < HTMLMediaElement.HAVE_ENOUGH_DATA) {
        rafRef.current = requestAnimationFrame(tickDetect);
        return;
      }

      const canvas = canvasRef.current;
      const ctx = canvas.getContext("2d");
      // match canvas aan video
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // debug: show canvas size in console rarely
      // console.log("Canvas size:", canvas.width, canvas.height);

      // Gebruik canvas direct bij detect -> doorgaans betrouwbaarder dan createImageBitmap op sommige devices
      let barcodes = [];
      try {
        barcodes = await detectorRef.current.detect(canvas);
      } catch (errDetect) {
        // fallback: probeer met ImageBitmap als detect(canvas) mislukt
        console.warn("detect(canvas) faalde, probeer createImageBitmap:", errDetect);
        try {
          const imgBitmap = await createImageBitmap(canvas);
          barcodes = await detectorRef.current.detect(imgBitmap);
        } catch (err2) {
          console.error("detect fallback faalde:", err2);
          setMessage("Detectiefout: " + (err2.message || err2));
        }
      }

      // Clear overlay drawing
      const overlay = overlayRef.current;
      const octx = overlay.getContext("2d");
      octx.clearRect(0, 0, overlay.width, overlay.height);

      // Draw red laser line (center)
      octx.strokeStyle = "rgba(255,50,50,0.9)";
      octx.lineWidth = 3;
      octx.beginPath();
      const y = overlay.height * 0.5;
      octx.moveTo(0, y);
      octx.lineTo(overlay.width, y);
      octx.stroke();

      if (barcodes && barcodes.length) {
        // take first barcode
        const bc = barcodes[0];
        const raw = bc.rawValue || "";
        console.log("Barcode gedetecteerd:", bc);
        // If boundingBox exists, draw it
        if (bc.boundingBox) {
          const box = bc.boundingBox; // {x, y, width, height}
          // boundingBox is in pixels corresponding to canvas size
          octx.strokeStyle = "rgba(0,220,120,0.95)";
          octx.lineWidth = 2;
          octx.strokeRect(box.x, box.y, box.width, box.height);
        }
        if (raw && raw !== lastBarcode) {
          setLastBarcode(raw);
          setArticleId("");
          setQuantity(1);
          setMessage(`Gescand: ${raw}`);
          // stop camera zodat gebruiker kan invoeren
          stopCamera();
          // focus artikel id input kort daarna (als aanwezig)
          setTimeout(() => {
            const el = document.getElementById("articleIdInput");
            if (el) el.focus();
          }, 200);
        }
      } else {
        // geen barcode; blijf scannen
        // console.log("Geen barcode in dit frame");
      }

    } catch (err) {
      console.error("tickDetect fout:", err);
    } finally {
      if (scanning) rafRef.current = requestAnimationFrame(tickDetect);
    }
  }

  function confirmItem() {
    if (!lastBarcode) { setMessage("Geen barcode om te bevestigen."); return; }
    const q = Number(quantity) || 1;
    const now = new Date();
    const item = { time: now.toISOString(), barcode: lastBarcode, articleId: (articleId||"").trim(), quantity: q };
    setItems(prev => [item, ...prev]);
    setLastBarcode(""); setArticleId(""); setQuantity(1); setMessage("Item toegevoegd");
    if (supported) setTimeout(startCamera, 350);
  }

  function downloadCSV() {
    if (!items.length) { setMessage("Er zijn geen items om te downloaden."); return; }
    let filename = window.prompt("Bestandsnaam (zonder extensie):", "inventaris");
    if (filename === null) return;
    filename = filename.trim() || "inventaris";
    if (!filename.toLowerCase().endsWith(".csv")) filename += ".csv";
    const header = "time,barcode,articleId,quantity\n";
    const rows = items.map(i => `${escapeCsv(i.time)},${escapeCsv(i.barcode)},${escapeCsv(i.articleId)},${escapeCsv(String(i.quantity))}`).join("\n");
    const blob = new Blob([header + rows], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    setMessage(`CSV gedownload (${filename})`);
  }

  function escapeCsv(v){ if (v==null) return ""; const s = String(v); if (s.includes(",")||s.includes('"')||s.includes("\n")) return '"' + s.replace(/"/g,'""') + '"'; return s; }

  function updateItemField(index, field, value) {
    setItems(prev => { const copy = [...prev]; copy[index] = { ...copy[index], [field]: field === "quantity" ? (Number(value)||0) : value }; return copy; });
  }
  function removeItem(index){ setItems(prev => prev.filter((_,i)=>i!==index)); }

  // Set overlay canvas size to match video each render
  useEffect(() => {
    const overlay = overlayRef.current;
    const video = videoRef.current;
    if (!overlay || !video) return;
    function syncSize() {
      overlay.width = video.videoWidth || video.clientWidth || 640;
      overlay.height = video.videoHeight || video.clientHeight || 480;
    }
    // call on interval for a short while until video has size
    const id = setInterval(syncSize, 150);
    setTimeout(() => clearInterval(id), 2000);
    return () => clearInterval(id);
  }, [scanning]);

  return (
    React.createElement("div", { style: { maxWidth: 900, margin: "0 auto", padding: 12 } },
      React.createElement("h2", null, "Barcode-inventarisatie"),
      React.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center", marginBottom: 10 } },
        React.createElement("button", { onClick: () => scanning ? stopCamera() : startCamera(), style: { padding: "8px 12px" } }, scanning ? "Stop camera" : "Start camera"),
        React.createElement("button", { onClick: downloadCSV, style: { padding: "8px 12px" } }, "Download CSV"),
        React.createElement("div", { style: { marginLeft: "auto", color: "#666" } }, supported === null ? "Controleer..." : supported ? "BarcodeDetector: ondersteund" : "BarcodeDetector: niet ondersteund")
      ),
      React.createElement("div", { style: { position: "relative", width: "100%", height: 420, background: "#000", borderRadius: 8, overflow: "hidden" } },
        React.createElement("video", { ref: videoRef, style: { width: "100%", height: "100%", objectFit: "cover" }, muted: true, playsInline: true }),
        React.createElement("canvas", { ref: canvasRef, style: { display: "none" } }),
        React.createElement("canvas", { ref: overlayRef, style: { position: "absolute", left: 0, top: 0, width: "100%", height: "100%", pointerEvents: "none" } })
      ),
      React.createElement("div", { style: { marginTop: 12, display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap" } },
        React.createElement("input", { type: "text", value: lastBarcode, onChange: e => setLastBarcode(e.target.value), placeholder: "Barcode (manueel of na scan)", style: { flex: "1 1 240px", padding: 8 } }),
        React.createElement("input", { id: "articleIdInput", type: "text", value: articleId, onChange: e => setArticleId(e.target.value), placeholder: "Artikel ID", style: { width: 160, padding: 8 } }),
        React.createElement("input", { type: "number", value: quantity, onChange: e => setQuantity(Number(e.target.value)), min: 1, style: { width: 100, padding: 8 } }),
        React.createElement("button", { onClick: confirmItem, style: { padding: "8px 12px" } }, "Bevestig item")
      ),
      message && React.createElement("div", { style: { marginTop: 8, color: "#444" } }, message),
      React.createElement("hr", { style: { margin: "16px 0" } }),
      React.createElement("div", null,
        React.createElement("table", { style: { width: "100%", borderCollapse: "collapse" } },
          React.createElement("thead", null,
            React.createElement("tr", null, ["Tijd","Barcode","Artikel ID","Aantal","Acties"].map(h => React.createElement("th", { key: h, style: { textAlign: "left", padding: 8 } }, h)))
          ),
          React.createElement("tbody", null,
            items.length === 0 ? React.createElement("tr", null, React.createElement("td", { colSpan: 5, style: { padding: 12, color: "#666" } }, "Geen items")) :
            items.map((it, i) => React.createElement("tr", { key: i },
              React.createElement("td", { style: { padding: 8 } }, new Date(it.time).toLocaleString()),
              React.createElement("td", { style: { padding: 8 } }, it.barcode),
              React.createElement("td", { style: { padding: 8 } }, React.createElement("input", { value: it.articleId, onChange: e => updateItemField(i, "articleId", e.target.value), style: { width: "100%", padding: 6 } })),
              React.createElement("td", { style: { padding: 8 } }, React.createElement("input", { type: "number", value: it.quantity, onChange: e => updateItemField(i, "quantity", e.target.value), style: { width: 80, padding: 6 } })),
              React.createElement("td", { style: { padding: 8 } }, React.createElement("button", { onClick: () => removeItem(i) }, "Verwijder"))
            ))
          )
        )
      )
    )
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(BarcodeInventory));
